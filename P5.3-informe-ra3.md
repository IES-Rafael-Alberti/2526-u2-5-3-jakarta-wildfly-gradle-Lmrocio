# P5.3 - Informe RA3 sobre el despliegue (WildFly contenedor + Gradle)

## a) Componentes y funcionamiento de los servicios del servidor

En mi despliegue de la aplicación de tareas (crud-file) sobre WildFly en contenedor, intervienen los siguientes componentes:

**1. Contenedor Docker**: Es el entorno aislado donde se ejecuta todo. Gracias a Docker, puedo tener un WildFly funcionando sin instalarlo directamente en mi máquina. Lo levanto con `docker run` y puedo pararlo, borrarlo y volver a empezar cuando quiera.

**2. WildFly (servidor de aplicaciones)**: Es el servidor Jakarta EE que recibe las peticiones HTTP y ejecuta mi aplicación. Internamente usa Undertow como servidor web. WildFly se encarga de gestionar el ciclo de vida de mi aplicación, las conexiones y todo lo necesario para que funcione.

**3. Aplicación WAR (crud-file.war)**: Es el archivo que contiene mi aplicación empaquetada. Incluye las clases Java compiladas (TaskResource, Task, FileTaskStore, etc.), el descriptor web.xml y los recursos estáticos. Cuando copio este archivo a la carpeta deployments de WildFly, el servidor lo detecta y lo despliega automáticamente.

**4. Puerto 8080**: Es el puerto donde WildFly escucha las peticiones de las aplicaciones. Cuando accedo a `http://localhost:8080/crud-file/api/tasks`, estoy entrando por este puerto.

**5. Puerto 9990**: Es el puerto de la consola de administración de WildFly. Desde ahí puedo ver el estado del servidor, desplegar aplicaciones manualmente, configurar datasources, etc.

**6. Endpoint REST (/api/tasks)**: Es la API que expone mi aplicación. Está definida en la clase TaskResource con las anotaciones @Path, @GET, @POST, @PUT y @DELETE. La ruta base /api viene de TasksApplication.

### Flujo de una petición

Cuando hago una petición como `GET http://localhost:8080/crud-file/api/tasks`:

1. La petición sale de mi navegador o curl hacia localhost:8080
2. Docker redirige esa petición al puerto 8080 del contenedor
3. Undertow (dentro de WildFly) recibe la petición
4. WildFly mira el contexto `/crud-file` y sabe que es para mi aplicación
5. Jakarta REST (JAX-RS) mapea `/api/tasks` a mi clase TaskResource y al método list()
6. El método ejecuta la lógica, lee del fichero JSON y devuelve la lista de tareas
7. La respuesta vuelve por el mismo camino hasta mi navegador

### Evidencias

[CAPTURA 1 - Inserta aquí una captura de docker ps mostrando el contenedor wildfly activo con los puertos 8080 y 9990 publicados]

[CAPTURA 2 - Inserta aquí una captura de docker logs -f wildfly donde se vea el despliegue del WAR crud-file.war]

[CAPTURA 3 - Inserta aquí una captura de curl http://localhost:8080/crud-file/api/tasks mostrando la respuesta JSON]

---

## b) Archivos principales de configuración y bibliotecas compartidas

### Archivos de configuración en WildFly

El archivo principal de configuración de WildFly es `standalone.xml`. Está ubicado en:

```
/opt/jboss/wildfly/standalone/configuration/standalone.xml
```

Este archivo XML controla prácticamente todo el comportamiento del servidor. Algunos ajustes que podría modificar ahí para mi despliegue:

- **Datasources**: Si mi aplicación necesitara conectarse a una base de datos MySQL o PostgreSQL, tendría que configurar aquí la conexión (URL, usuario, password).
- **Puertos**: Si quisiera cambiar el puerto por defecto 8080 por otro, lo haría en este archivo.
- **Logs**: Para cambiar el nivel de log (por ejemplo, poner DEBUG para ver más detalle) o configurar dónde se guardan los logs.
- **Timeouts**: Ajustar tiempos de espera para conexiones.

Para extraer este archivo y verlo puedo usar:
```bash
docker cp wildfly:/opt/jboss/wildfly/standalone/configuration/standalone.xml ./standalone.xml
```

### Dependencias "provided"

En mi `build.gradle` tengo esta línea:

```groovy
dependencies {
    compileOnly 'jakarta.platform:jakarta.jakartaee-api:10.0.0'
}
```

El `compileOnly` (equivalente a "provided" en Maven) significa que esa dependencia solo se usa para compilar, pero NO se incluye en el WAR final. Esto es porque WildFly ya trae todas las librerías de Jakarta EE incluidas.

**Ventajas de esto:**
- El WAR es mucho más pequeño (el mío pesa solo unos pocos KB)
- No hay conflictos de versiones entre las librerías que yo incluya y las del servidor
- Aprovecho las optimizaciones que WildFly hace sobre esas librerías

### Evidencias

[CAPTURA 4 - Inserta aquí una captura del comando docker exec -it wildfly ls /opt/jboss/wildfly/standalone/configuration/ mostrando los archivos de configuración]

[CAPTURA 5 - Inserta aquí una captura del build.gradle donde se ve compileOnly]

---

## c) Cooperación con el servidor web (proxy / reverse proxy) y HTTPS

### Configuración de Reverse Proxy con Nginx

En mi despliegue de la práctica accedí directamente a WildFly por localhost:8080. Pero en un entorno real de producción, lo normal es poner un servidor web frontal (como Nginx) delante que actúe como reverse proxy.

He creado una configuración de Nginx que:
- Publica la API bajo la ruta `/api/`
- No expone el puerto 9990 (consola de administración) al exterior
- Configura HTTPS con certificados TLS

El archivo `nginx.conf` quedaría así:

```nginx
events {
    worker_connections 1024;
}

http {
    upstream wildfly_backend {
        server wildfly:8080;
    }

    # Redirigir HTTP a HTTPS
    server {
        listen 80;
        server_name localhost;
        return 301 https://$server_name$request_uri;
    }

    # Servidor HTTPS
    server {
        listen 443 ssl;
        server_name localhost;

        ssl_certificate /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers HIGH:!aNULL:!MD5;

        # Proxy para la API
        location /api/ {
            proxy_pass http://wildfly_backend/crud-file/api/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # Pagina principal
        location / {
            proxy_pass http://wildfly_backend/crud-file/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }
    }
}
```

### Qué cambia respecto a mi despliegue actual

1. **Puertos expuestos**: Ahora solo expongo el 80 y 443 de Nginx al host. El puerto 8080 de WildFly solo es accesible dentro de la red Docker. El 9990 no se expone en absoluto.

2. **URLs más limpias**: En vez de `http://localhost:8080/crud-file/api/tasks`, ahora sería `https://localhost/api/tasks`.

3. **Seguridad**: Todo el tráfico va cifrado con HTTPS. Aunque alguien intercepte la comunicación, no puede ver los datos.

### Configuración de TLS (HTTPS)

Para configurar TLS, necesito:

1. Generar certificados (en desarrollo uso autofirmados):
```bash
openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
  -keyout key.pem -out cert.pem \
  -subj "/CN=localhost"
```

2. Montar los certificados en el contenedor de Nginx (lo hago con volúmenes en Docker Compose).

**Ventajas de HTTPS:**
- Los datos viajan cifrados, nadie puede leerlos aunque intercepte el tráfico
- Los navegadores modernos marcan como "No seguro" las páginas sin HTTPS
- Es obligatorio para producción

**Sobre mi aplicación o WildFly:** No tengo que cambiar nada en el código ni en WildFly. El cifrado TLS lo gestiona Nginx, y la comunicación entre Nginx y WildFly va por la red interna de Docker (que ya es segura).

### Evidencias

[CAPTURA 6 - Inserta aquí una captura del archivo nginx.conf creado]

[CAPTURA 7 - Inserta aquí una captura de los comandos para generar los certificados SSL]

---

## d) Mecanismos de seguridad del servidor de aplicaciones

### Medidas de seguridad aplicadas en la práctica

1. **Usuario de administración con contraseña**: He creado un usuario para acceder a la consola 9990 usando el script `add-user.sh`. Sin este usuario, nadie puede entrar a la consola de gestión.

2. **Puertos controlados**: Solo expuse los puertos necesarios (8080 y 9990) y no otros que WildFly pueda usar internamente.

### Medidas que añadiría para producción

**1. No exponer el puerto 9990 al exterior**

En producción, la consola de administración solo debería ser accesible desde una VPN o red interna. En mi docker-compose final, el puerto 9990 no se mapea al host.

Justificación: Si un atacante accede a la consola, puede desplegar aplicaciones maliciosas, cambiar la configuración del servidor o pararlo.

**2. Usar HTTPS obligatorio**

Todo el tráfico debe ir cifrado. Configuraría Nginx delante con TLS y redirección automática de HTTP a HTTPS.

Justificación: Sin cifrado, cualquiera en la misma red puede ver los datos que se envían (passwords, tokens, datos de usuarios).

**3. Gestión de secretos con variables de entorno o Docker Secrets**

Las contraseñas nunca deben estar en el código ni en el Dockerfile. En su lugar:
- Usar variables de entorno que se inyectan al arrancar el contenedor.
- Usar Docker Secrets para datos sensibles.
- Nunca commitear archivos con credenciales al repositorio Git.

Ejemplo de cómo NO hacerlo:
```dockerfile
# MAL - La password queda en el historial de Git
ENV DB_PASSWORD=mipassword123
```

Ejemplo correcto:
```yaml
# En docker-compose.yml
environment:
  - DB_PASSWORD_FILE=/run/secrets/db_password
secrets:
  - db_password
```

**4. Logs centralizados y persistentes**

Configuraría los logs para que se guarden fuera del contenedor, usando volúmenes. Así si el contenedor se borra, no pierdo los logs.

Justificación: Los logs son fundamentales para detectar ataques, errores y auditar qué ha pasado. Si se pierden, no hay forma de investigar un incidente.

**5. Principio de mínimos privilegios**

El contenedor no debería correr como root. En mi Dockerfile final usaría un usuario sin privilegios.

Justificación: Si un atacante consigue ejecutar código en el contenedor, tendrá menos capacidad de hacer daño si no es root.

### Evidencias

[CAPTURA 8 - Inserta aquí una captura de docker ps mostrando qué puertos están expuestos]

[CAPTURA 9 - Inserta aquí una captura del docker-compose.yml donde se ve que el puerto 9990 no se expone al host]

---

## e) Componentes web del servidor de aplicaciones

### Qué es el WAR y qué contiene

El archivo WAR (Web Application Archive) es el formato estándar para empaquetar aplicaciones web en Jakarta EE. Es básicamente un ZIP con una estructura específica.

Mi WAR `crud-file.war` contiene:

```
crud-file.war
├── WEB-INF/
│   ├── web.xml              # Descriptor de despliegue
│   └── classes/
│       └── com/example/tasks/
│           ├── Task.class
│           ├── TaskResource.class
│           ├── TaskStore.class
│           ├── FileTaskStore.class
│           └── TasksApplication.class
└── index.html               # Página de bienvenida
```

### El contexto/ruta base de la aplicación

El contexto es la parte de la URL que identifica a mi aplicación. Por defecto, WildFly usa el nombre del archivo WAR.

Como mi WAR se llama `crud-file.war`, el contexto es `/crud-file`.

Si quisiera cambiarlo, podría:
- Renombrar el WAR (por ejemplo `api.war` -> contexto `/api`)
- Crear un archivo `jboss-web.xml` en WEB-INF con el contexto que quiera

### Quién sirve la API: el contenedor web (Undertow)

Dentro de WildFly, el componente que se encarga de recibir las peticiones HTTP y servir las aplicaciones web es Undertow. Es el "contenedor web" o "contenedor de servlets".

Undertow:
- Escucha en el puerto 8080.
- Recibe las peticiones HTTP.
- Las enruta a la aplicación correcta según el contexto.
- Ejecuta los servlets/recursos REST.
- Devuelve las respuestas.

### Desglose de una URL real

URL: `http://localhost:8080/crud-file/api/tasks/1`

| Parte | Valor | Significado |
|-------|-------|-------------|
| Protocolo | http | Protocolo de comunicación |
| Host | localhost | Nombre del servidor |
| Puerto | 8080 | Puerto donde escucha WildFly |
| Contexto | /crud-file | Identifica mi aplicación (nombre del WAR) |
| Application Path | /api | Definido en @ApplicationPath de TasksApplication |
| Recurso | /tasks | Definido en @Path de TaskResource |
| Parámetro | /1 | ID de la tarea (definido con @PathParam) |

### Evidencias

[CAPTURA 10 - Inserta aquí una captura del navegador accediendo a http://localhost:8080/crud-file/api/tasks]

[CAPTURA 11 - Inserta aquí una captura de curl http://localhost:8080/crud-file/api/tasks/1]

[CAPTURA 12 - Inserta aquí una captura de los logs de WildFly mostrando el acceso a la API]

---

## f) Parámetros necesarios para el despliegue

### Parámetros utilizados en mi despliegue

**1. Parámetros de docker run**

```bash
docker run -d --name wildfly -p 8080:8080 -p 9990:9990 quay.io/wildfly/wildfly:latest /opt/jboss/wildfly/bin/standalone.sh -b 0.0.0.0 -bmanagement 0.0.0.0
```

- `-d`: Ejecuta el contenedor en segundo plano (detached).
- `--name wildfly`: Nombre del contenedor para poder referenciarlo después.
- `-p 8080:8080`: Mapea el puerto 8080 del host al 8080 del contenedor.
- `-p 9990:9990`: Mapea el puerto 9990 para la consola de administración.
- `-b 0.0.0.0`: WildFly acepta conexiones desde cualquier IP (necesario para acceder desde fuera del contenedor).
- `-bmanagement 0.0.0.0`: La consola de administración acepta conexiones externas.

**Si `-p 8080:8080` estuviera mal:** No podría acceder a la aplicación desde mi navegador. La petición no llegaría al contenedor.

**Si olvidara `-b 0.0.0.0`:** WildFly solo escucharía en localhost del contenedor y no podría acceder desde mi máquina.

**2. Nombre del WAR**

En mi `build.gradle`:
```groovy
war {
    archiveFileName = 'crud-file.war'
}
```

Esto determina que el contexto de mi aplicación será `/crud-file`.

**Si lo cambiara a `tareas.war`:** Tendría que acceder por `/tareas` en vez de `/crud-file`. Todas las URLs cambiarían.

**3. Ruta de despliegue**

```bash
docker cp build/libs/crud-file.war wildfly:/opt/jboss/wildfly/standalone/deployments/
```

El directorio `/opt/jboss/wildfly/standalone/deployments/` es especial: WildFly monitoriza esta carpeta y despliega automáticamente cualquier WAR que se copie ahí.

**Si copiara el WAR a otra ruta:** No se desplegaría. Tendría que desplegarlo manualmente desde la consola.

**4. Versión de Java**

```groovy
def javaVersion = JavaVersion.VERSION_17
java {
    sourceCompatibility = javaVersion
    targetCompatibility = javaVersion
}
```

Mi código se compila para Java 17. WildFly 27+ soporta Java 17.

**Si compilara para Java 21 y WildFly solo soportara Java 17:** Obtendría un error de versión de clase incompatible al desplegar.

**5. Application Path**

```java
@ApplicationPath("/api")
public class TasksApplication extends Application {
}
```

Define que todos los recursos REST están bajo `/api`.

**Si lo cambiara a `/rest`:** Las URLs pasarían de `/crud-file/api/tasks` a `/crud-file/rest/tasks`.

### Evidencias

[CAPTURA 13 - Inserta aqui una captura del comando docker run completo que usaste]

[CAPTURA 14 - Inserta aqui una captura del build.gradle completo]

[CAPTURA 15 - Inserta aqui una captura del comando docker cp y la confirmacion de despliegue en logs]

[CAPTURA 15.2 - Inserta aqui una captura del comando docker cp y la confirmacion de despliegue en logs]

---

## g) Pruebas de funcionamiento y rendimiento

### Pruebas funcionales realizadas

**1. Listar todas las tareas (GET)**
```bash
curl http://localhost:8080/crud-file/api/tasks
```
Respuesta: Lista JSON con todas las tareas existentes.

**2. Obtener una tarea por ID (GET)**
```bash
curl http://localhost:8080/crud-file/api/tasks/1
```
Respuesta: JSON de la tarea con id 1 o error 404 si no existe.

**3. Crear una nueva tarea (POST)**
```bash
curl -X POST http://localhost:8080/crud-file/api/tasks \
  -H "Content-Type: application/json" \
  -d '{"title":"Tarea de prueba","completed":false}'
```
Respuesta: JSON de la tarea creada con su ID asignado (HTTP 201).

**4. Actualizar una tarea (PUT)**
```bash
curl -X PUT http://localhost:8080/crud-file/api/tasks/1 \
  -H "Content-Type: application/json" \
  -d '{"title":"Tarea actualizada","completed":true}'
```
Respuesta: JSON de la tarea actualizada.

**5. Eliminar una tarea (DELETE)**
```bash
curl -X DELETE http://localhost:8080/crud-file/api/tasks/1
```
Respuesta: HTTP 204 No Content si se borró correctamente.

### Prueba de rendimiento con `hey`

Ejecuté una prueba de carga con `hey` para ver cómo aguanta mi API:

```bash
hey -n 1000 -c 10 -m POST -H "Content-Type: application/json" -d '{"title":"Tarea de prueba","completed":false}' http://localhost:8080/crud-file/api/tasks
```

Este comando lanza 1000 peticiones en total, manteniendo 10 usuarios simultáneos (concurrencia).

### Análisis de los resultados

**Métricas a observar:**

- **Requests per second**: **111.84**. Indica cuántas peticiones puede servir el servidor por segundo. Cuanto más alto, mejor rendimiento.
- **Time per request**: **0.08**. Tiempo medio que tarda cada petición. Cuanto más bajo, mejor.
- **Failed requests**: **0**. Si hay fallos, algo va mal.

**Interpretación:**

Mi despliegue es bastante estable y capaz de manejar tráfico decente para un entorno de desarrollo/pruebas.

La latencia media debería estar por debajo de 50ms para considerarse buena en local.

Si hubiera "Failed requests" mayores que 0, tendría que revisar los logs de WildFly para ver qué está pasando (quizá el servidor se queda sin memoria o hay algún cuello de botella).

### Evidencias

[CAPTURA 18 - Inserta aquí una captura del comando hey completo y su salida con las métricas]

---

## h) Documentación de administración y recomendaciones

### Mini-guía de administración para el despliegue de crud-file en WildFly

Esta guía permite a cualquier persona del equipo levantar, administrar y desplegar nuevas versiones de la aplicación.

---

#### 1. Requisitos previos

- Docker instalado y funcionando
- Gradle instalado (o usar el wrapper gradlew)
- Git para clonar el repositorio

Verificar Docker:
```bash
docker --version
```

#### 2. Levantar WildFly

**Opción rápida (contenedor individual):**

```bash
# Descargar imagen
docker pull quay.io/wildfly/wildfly:latest

# Levantar contenedor
docker run -d --name wildfly \
  -p 8080:8080 -p 9990:9990 \
  quay.io/wildfly/wildfly:latest \
  /opt/jboss/wildfly/bin/standalone.sh -b 0.0.0.0 -bmanagement 0.0.0.0
```

**Opción recomendada (Docker Compose):**

```bash
docker-compose up -d
```

Esto levanta WildFly + Nginx con toda la configuración ya hecha.

#### 3. Crear usuario de administración (solo primera vez)

```bash
docker exec -it wildfly /opt/jboss/wildfly/bin/add-user.sh
```

- Seleccionar opción `a) Management User`
- Introducir usuario y contraseña (recordarlos)
- Dejar grupos en blanco
- Confirmar con `yes`

#### 4. Compilar la aplicación

Desde la raíz del proyecto:

```bash
./gradlew clean build
```

El WAR se genera en `build/libs/crud-file.war`

#### 5. Desplegar una nueva versión

```bash
docker cp build/libs/crud-file.war wildfly:/opt/jboss/wildfly/standalone/deployments/
```

WildFly detecta automáticamente el nuevo WAR y lo despliega. Puedes ver el proceso en los logs.

#### 6. Comprobar el estado

**Ver si el contenedor está corriendo:**
```bash
docker ps
```

**Ver logs en tiempo real:**
```bash
docker logs -f wildfly
```

Buscar el mensaje `Deployed "crud-file.war"` para confirmar el despliegue.

**Probar endpoint de prueba:**
```bash
curl http://localhost:8080/crud-file/api/tasks
```

Si devuelve JSON (aunque sea una lista vacía `[]`), la aplicación funciona.

**Acceder a la consola web:**
```
http://localhost:9990
```

#### 7. Comandos útiles

| Acción | Comando |
|--------|---------|
| Parar contenedor | `docker stop wildfly` |
| Arrancar contenedor | `docker start wildfly` |
| Reiniciar contenedor | `docker restart wildfly` |
| Borrar contenedor | `docker rm -f wildfly` |
| Ver logs | `docker logs -f wildfly` |
| Entrar al contenedor | `docker exec -it wildfly bash` |

#### 8. Recomendaciones para evitar errores comunes

1. **El WAR no se despliega**: Comprobar que el nombre del archivo termina en `.war` y que se copia a la ruta correcta (`/opt/jboss/wildfly/standalone/deployments/`).

2. **No puedo acceder a la aplicación**: Verificar que el contenedor está corriendo (`docker ps`) y que los puertos están mapeados correctamente.

3. **Error "Connection refused"**: Probablemente olvidaste el parámetro `-b 0.0.0.0` al arrancar WildFly.

4. **La consola 9990 no carga**: Verificar que está el parámetro `-bmanagement 0.0.0.0` y que el usuario de administración está creado.

5. **Cambios en el código no se reflejan**: Hay que volver a compilar (`gradlew build`) y copiar el WAR. WildFly no recoge cambios automáticamente del código fuente.

6. **El contenedor se para solo**: Revisar logs con `docker logs wildfly` para ver el error. Puede ser falta de memoria o un error en la configuración.

#### 9. Arquitectura del despliegue

```
                    ┌─────────────────────────────────────────┐
                    │              Docker Host                │
                    │                                         │
   Usuario ──────►  │  ┌─────────┐      ┌──────────────────┐ │
   (Puerto 80/443)  │  │  Nginx  │─────►│     WildFly      │ │
                    │  │ (proxy) │      │   (puerto 8080)  │ │
                    │  └─────────┘      │                  │ │
                    │                   │  ┌────────────┐  │ │
                    │                   │  │ crud-file  │  │ │
                    │                   │  │   .war     │  │ │
                    │                   │  └────────────┘  │ │
                    │                   └──────────────────┘ │
                    └─────────────────────────────────────────┘
```

### Evidencias

[CAPTURA 20 - Inserta aquí una captura del docker-compose up -d funcionando]

[CAPTURA 21 - Inserta aquí una captura de docker ps mostrando todos los contenedores levantados]

---

## i) Virtualización, nube o contenedores en el despliegue

He creado un despliegue completo usando Docker Compose que incluye:
- Servidor web frontal (Nginx) con HTTPS
- Servidor de aplicaciones (WildFly)
- Mi aplicación REST (crud-file)

### Estructura de archivos

```
proyecto/
├── docker-compose.yml
├── nginx/
│   ├── nginx.conf
│   └── ssl/
│       ├── cert.pem
│       └── key.pem
├── wildfly/
│   └── deployments/
│       └── crud-file.war
└── logs/
    ├── nginx/
    └── wildfly/
```

### Archivo docker-compose.yml

```yaml
services:
  # Servicio de Aplicación (Backend)
  wildfly:
    image: quay.io/wildfly/wildfly:latest
    container_name: wildfly_backend
    command: /opt/jboss/wildfly/bin/standalone.sh -b 0.0.0.0
    restart: always
    deploy:
      resources:
        limits:
          memory: 512M
    volumes:
      # Despliegue automático del WAR al arrancar
      - ./build/libs/crud-file.war:/opt/jboss/wildfly/standalone/deployments/crud-file.war
      # Persistencia de logs en carpeta local
      - ./logs/wildfly:/opt/jboss/wildfly/standalone/log
    networks:
      - app-network
    healthcheck:
      # Comprueba que el servidor responde internamente antes de darlo por válido
      test: ["CMD", "curl", "-f", "http://localhost:8080/crud-file"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 40s

  # Servicio Web / Proxy (Frontend)
  nginx:
    image: nginx:alpine
    container_name: nginx_proxy
    restart: always
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/ssl:/etc/nginx/ssl:ro
      - ./logs/nginx:/var/log/nginx
    depends_on:
      wildfly:
        condition: service_healthy
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "nginx", "-t"]
      interval: 30s
      timeout: 10s
      retries: 3

# Red interna para que se vean entre ellos
networks:
  app-network:
    driver: bridge
```

### Archivo nginx/nginx.conf

```nginx
events {
    worker_connections 1024;
}

http {
    upstream wildfly_backend {
        server wildfly:8080;
    }

    # Redirigir HTTP a HTTPS
    server {
        listen 80;
        server_name localhost;
        return 301 https://$server_name$request_uri;
    }

    # Servidor HTTPS
    server {
        listen 443 ssl;
        server_name localhost;

        ssl_certificate /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers HIGH:!aNULL:!MD5;

        # Proxy para la API
        location /api/ {
            proxy_pass http://wildfly_backend/crud-file/api/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # Pagina principal
        location / {
            proxy_pass http://wildfly_backend/crud-file/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }
    }
}
```

### Características del despliegue

**1. Volúmenes para logs:**
Los logs tanto de Nginx como de WildFly se guardan en carpetas del host (`./logs/`). Así no se pierden aunque se borren los contenedores.

**2. Healthchecks:**
- Nginx verifica que su configuración sea válida
- WildFly comprueba que la API responde correctamente
- Si un servicio falla el healthcheck, Docker puede reiniciarlo

**3. Reinicio automático:**
Con `restart: unless-stopped`, los contenedores se reinician automáticamente si fallan o si se reinicia el servidor, excepto si los paramos manualmente.

**4. Limitación de recursos:**
WildFly tiene limitada la CPU a 1 core y la memoria a 512MB. Esto evita que un problema en la aplicación consuma todos los recursos del servidor.

**5. Redes:**
Los contenedores están en una red privada (`app-network`). WildFly no expone ningún puerto al host directamente, solo es accesible a través de Nginx.

**6. Seguridad:**
- El puerto 9990 no está expuesto
- Solo Nginx está accesible desde fuera (puertos 80 y 443)
- El tráfico va cifrado con HTTPS

### Cómo desplegar

1. Generar certificados SSL (para desarrollo):
```bash
mkdir -p nginx/ssl
openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
  -keyout nginx/ssl/key.pem -out nginx/ssl/cert.pem \
  -subj "/CN=localhost"
```

2. Compilar la aplicación y copiar el WAR:
```bash
./gradlew clean build
mkdir -p wildfly/deployments
cp build/libs/crud-file.war wildfly/deployments/
```

3. Levantar todo:
```bash
docker-compose up -d
```

4. Verificar que funciona:
```bash
docker-compose ps
curl -k https://localhost/api/tasks
```

### Mejora: Separación frontend/backend

Una mejora adicional sería tener el frontend (si lo hubiera) en un contenedor separado. La arquitectura quedaría:

```
Usuario → Nginx → Frontend (puerto 80/443)
                → Backend (WildFly) solo red interna
```

El frontend se comunicaría con el backend a través de la red Docker, sin exponer WildFly al exterior.

### Evidencias

[CAPTURA 22 - Inserta aquí una captura del archivo docker-compose.yml completo]

[CAPTURA 25 - Inserta aquí una captura de curl -k https://localhost/api/tasks funcionando]

[CAPTURA 26 - Inserta aquí una captura de los logs de ambos contenedores]

